\documentclass[a5paper]{report}
% Smaller paper size for easier reading, print two pages per a4 side.
\usepackage[margin=2cm]{geometry}
\usepackage{pdflscape}
\usepackage{csquotes}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{microtype}
\usepackage{calc}
\usepackage[T1]{fontenc}
\setlist[description]{leftmargin=\parindent,labelindent=\parindent}%Indent descriptions
\MakeOuterQuote{"}
% Indent first paragraphs in sections and chapters
\usepackage{indentfirst}
\title{Information Retrieval Notes}
\author{Artem Vasenin}
\date{Last updated \today}

% Make quotes smaller than normal text
\expandafter\def\expandafter\quote\expandafter{\quote\small\singlespacing}


% Keep each sentense on separate line to help with version control.
% Quotes can remain on one line since they don't usually change.

\begin{document}

\maketitle
\cleardoublepage
\pagenumbering{gobble}
\tableofcontents
\cleardoublepage
\pagenumbering{arabic}

\chapter{Boolean Retrieval}
\section{Index}
Any query is posed as a boolean expression of terms.
First we create an index of words that occur in each text, this is done offline.
E.g.
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
 & \begin{tabular}[c]{@{}l@{}}Anthony and \\ Cleopatra\end{tabular} & \begin{tabular}[c]{@{}l@{}}Julius \\ Caesar\end{tabular} & \begin{tabular}[c]{@{}l@{}}The \\ Tempest\end{tabular} & Hamlet & Othello \\ \hline
Antony & 1 & 1 & 0 & 0 & 0 \\ \hline
Brutus & 1 & 1 & 0 & 1 & 0 \\ \hline
Caesar & 1 & 1 & 0 & 1 & 1 \\ \hline
Calpurnia & 0 & 1 & 0 & 0 & 0 \\ \hline
Cleopatra & 1 & 0 & 0 & 0 & 0 \\ \hline
mercy & 1 & 0 & 1 & 1 & 1 \\ \hline
worser & 1 & 0 & 1 & 1 & 1 \\ \hline
\end{tabular}
\end{center}

When we compute results of a query we first invert corresponding to NOT terms and then compute a bitwise AND and OR between vectors for each term.
A few observations:
\begin{itemize}
\item The matrix is very sparse.
\item Doesn't support more complex operations, such as proximity search.
\end{itemize}

\section{Inverted Index}
To make storing information more efficient we can use inverted matrix which only documents things that occur.
The inverted index is a dictionary, with terms for keys and \emph{posting lists} for values.
A posting list is a sorted list which documents which documents the term occurs in.

Now to compute an AND query we compute and intersection of posting lists.
This can be done in $O(n)$ where $n$ is the number of documents in collection, in practice much faster.

When computing a conjunctive query with more than two terms we process them based on length of posting lists, in ascending order.
For disjunctive terms we can estimate the size of result using the sum of sizes of disjuncts.
\end{document}
